import sys
import csv
import os
from multiprocessing import Pool
from multiprocessing import Process, Lock

asmfilepath = '../dataset-asm-reaserch/train/'
threadnumber = 100

opcode_list = []
feature_list = []

if len(sys.argv) > 2:
    asmfilepath = sys.argv[1]
    threadnumber = int(sys.argv[2])
    print "use "+ str(threadnumber) + " processes"
else:
    print "use default folder and thread number..."

def get_feature_attribute():
    global opcode_list
    global feature_list
    # opcode as feature
    asmopcode = 'asm_opcode.txt'
    with open(asmopcode, 'rb') as content:
        for line in content.readlines():
            opcode = line.split(' - ')
            if '/' in opcode[0]:
                opcode_list.extend([opcode[0].split('/')[0], opcode[0].split('/')[1]])
            else:
                opcode_list.append(opcode[0])
    
    #feature pick up preparation
    feature_list = [["md5"] + opcode_list]
    
    opcode_list = ['\t\t' + op.lower() for op in opcode_list]
    
    # feature from FC survey
    asmopcode = 'asm_opcode3.txt'
    
    with open(asmopcode, 'rb') as content:
        for line in content.read().splitlines():
            opcode_list.append(line.lower())
            feature_list[0]+=[line]


def get_feature():
    global opcode_list
    global feature_list
    thread = 1000

    totalfilenumber = len(os.listdir(asmfilepath))
    currentunmber = 0
    for asmfile in os.listdir(asmfilepath):
        currentunmber += 1
        print str(currentunmber)+'/'+str(totalfilenumber), asmfile
        # The following table provides a list of x86-Assembler mnemonics, that is not complete.
        # Most of them can be found, for others see at www.intel.com
        # http://www.mathemainzel.info/files/x86asmref.html
        # count add, sub, mov, xor, push, pop, cmp, jz, jnz, je, jne, ja,
        with open(asmfilepath+asmfile) as filecontent:
            content_feature = [0] * len(opcode_list)
    
            for line in filecontent:
                for idx, op in enumerate(opcode_list):
                    if op in line.lower():
                        content_feature[idx] +=1
            feature_list += ([[asmfile.split('.asm')[0]] + content_feature])

def f(l, asmfile_sublist, index):
    #print asmfile_sublist
    global opcode_list
    feature_list = []
    global asmfilepath

    totalfilenumber = len(asmfile_sublist)
    currentunmber = 0
    for asmfile in asmfile_sublist:
        currentunmber += 1
        print 'P-'+ str(index+1)+ ': ' +str(currentunmber)+'/'+str(totalfilenumber), asmfile
        # The following table provides a list of x86-Assembler mnemonics, that is not complete.
        # Most of them can be found, for others see at www.intel.com
        # http://www.mathemainzel.info/files/x86asmref.html
        # count add, sub, mov, xor, push, pop, cmp, jz, jnz, je, jne, ja,
        with open(asmfilepath+asmfile) as filecontent:
            content_feature = [0] * len(opcode_list)
    
            for line in filecontent:
                for idx, op in enumerate(opcode_list):
                    if op in line.lower():
                        content_feature[idx] +=1
            l.acquire()
            #feature_list += ([[asmfile.split('.asm')[0]] + content_feature])
            generate_csv2([[asmfile.split('.asm')[0]] + content_feature])
            l.release()

def generate_csv():
    global feature_list
    output_train_asm = 'dataset/train_asm.csv'
    with open(output_train_asm, 'wb') as output:
        writer = csv.writer( output, delimiter=",")
        for row in feature_list:
            writer.writerow(row)

def generate_csv2(feature):
    global feature_list
    output_train_asm = 'dataset/train_asm.csv'
    with open(output_train_asm, 'a') as output:
        writer = csv.writer( output, delimiter=",")
        for row in feature:
            writer.writerow(row)

if __name__ == '__main__':
    lock = Lock()

    all_data = os.listdir(asmfilepath)
    data = []
    for item in all_data:
        if not item.startswith('.'):
            data.append(item)

    
    #threadnumber = 10
    if threadnumber > len(data):
        threadnumber = len(data)
    p = Pool(threadnumber)

    #print data
    elementnumber = len(data)/threadnumber
    chunks = [data[x:x+elementnumber] for x in range(0, len(data), elementnumber)]

    get_feature_attribute()
    # set csv title
    generate_csv()

    #get_feature()
    for idx, chunk in enumerate(chunks):
        p = Process(target=f, args=(lock, chunk, idx))
        p.start()
    p.join()
    print 'Finish'
    #generate_csv()